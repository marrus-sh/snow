// Generated by CoffeeScript 1.12.4

/*

    ................. SNOW ..................

     A client-side frontend for Mastodon, a
    free & open-source social network server.
               - - by Kibigo! - -

        Licensed under the MIT License.
           Source code available at:
       https://github.com/marrus-sh/snow

                Version 0.1.0
 */

(function() {
  "use strict;";
  var FROM_PUBLIC, FROM_TAG, FROM_USER, GLOBAL, HOME, LAp, LAt, LAu, LCl, LEn, LFa, LOCAL, LPo, LPr, LRe, LRo, LTi, Lab, Locales, NOTFOUND, ONLY_LOCAL, ONLY_MEDIA, POST, SHOW_POST, SHOW_TIMELINE, SHOW_USER, TAG, USER, WITH_MENTIONS, authorize, cleanup, config, go, init, localized, locate, nobody, notfound, post, state, timeline, user, Ε, Σ, Τ, σ, τ,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Object.defineProperty(window, "Snow", {
    value: Object.freeze({
      "ℹ": "https://github.com/marrus-sh/snow",
      "Nº": 1.0
    }),
    enumerable: true
  });

  config = {};

  state = {};

  localized = {};

  cleanup = [];

  Lab = LAp = LAt = LAu = LCl = LEn = LFa = LPo = LPr = LRe = LRo = LTi = void 0;

  FROM_PUBLIC = 0x1;

  FROM_USER = 0x2;

  FROM_TAG = 0x4;

  ONLY_LOCAL = 0x8;

  ONLY_MEDIA = 0x10;

  WITH_MENTIONS = 0x20;

  SHOW_TIMELINE = 0x40;

  SHOW_USER = 0x80;

  SHOW_POST = 0x100;

  NOTFOUND = 0;

  HOME = SHOW_TIMELINE;

  LOCAL = SHOW_TIMELINE | FROM_PUBLIC | ONLY_LOCAL;

  GLOBAL = SHOW_TIMELINE | FROM_PUBLIC;

  TAG = SHOW_TIMELINE | FROM_TAG;

  USER = SHOW_TIMELINE | FROM_USER | SHOW_USER;

  POST = SHOW_USER | SHOW_POST;

  Locales = {};

  Locales.en = {
    "auth.placeholder": "example.com",
    "auth.query": "What's your instance?",
    "auth.username": "username",
    "config.title": "Snow Web Client",
    "error.laboratory": "This version of Laboratory is not supported.",
    "location.all": "all",
    "location.global": "global",
    "location.local": "local",
    "location.media": "media",
    "location.tag": "tag",
    "location.user": "user",
    "link.home": "Home",
    "link.local": "Local",
    "link.global": "Global",
    "notfound.notfound": "Not found!",
    "notfound.message": "The page you were looking for does not exist."
  };

  init = function() {
    var INITIAL_STATE, data, elt, initial, j, len, locale, message, prop, ref, ref1, ref2, run, value;
    if ((elt = document.getElementById("snow-config")) && elt.tagName.toUpperCase() === "SCRIPT" && (elt.type === "application/json" || elt.type === "text/plain")) {
      config = JSON.parse(elt.text);
    }
    if ((typeof INITIAL_STATE !== "undefined" && INITIAL_STATE !== null ? INITIAL_STATE.meta : void 0) == null) {
      INITIAL_STATE = {
        meta: {}
      };
    }
    initial = {
      title: INITIAL_STATE.meta.title,
      basename: INITIAL_STATE.meta.router_basename != null ? INITIAL_STATE.meta.router_basename : "/web",
      locale: INITIAL_STATE.meta.locale,
      root: INITIAL_STATE.meta.react_root,
      defaultPrivacy: ((ref = INITIAL_STATE.composer) != null ? ref.default_privacy : void 0) || "unlisted",
      accessToken: INITIAL_STATE.meta.accessToken,
      origin: INITIAL_STATE.meta.origin || "/"
    };
    ref1 = ["title", "basename", "locale", "root", "defaultPrivacy", "accessToken", "origin"];
    for (j = 0, len = ref1.length; j < len; j++) {
      prop = ref1[j];
      if (config[prop] == null) {
        config[prop] = initial[prop];
      }
    }
    config.root = (function() {
      switch (false) {
        case !(config.root && (elt = document.getElementById(String(config.root)))):
          return elt;
        case !(elt = document.getElementById("frontend")):
          return elt;
        case !(elt = (document.getElementsByClassName("app-body")).item(0)):
          return elt;
        default:
          return document.body;
      }
    })();
    config.root.classList.add("🌨");
    if (config.display == null) {
      config.display = [];
    }
    if (!(config.display instanceof Array)) {
      config.display = [config.display];
    }
    config.root.setAttribute("data-snow-display", config.display.join(" "));
    ref2 = config.locales;
    for (locale in ref2) {
      data = ref2[locale];
      if (!(Locales[locale] instanceof Object)) {
        Locales[locale] = {};
      }
      for (message in data) {
        value = data[message];
        Locales[locale][message] = value;
      }
    }
    if (config.locale == null) {
      config.locale = "en";
    }
    config.root.setAttribute("lang", config.locale);
    if (config.title == null) {
      config.title = Ε("config.title");
    }
    document.title = config.title;
    run = function() {
      var callback;
      if (!(Laboratory.ℹ === "https://github.com/marrus-sh/laboratory" && Laboratory.Nº >= 5)) {
        throw new TypeError(Ε("error.laboratory"));
      }
      Lab = Laboratory;
      LAp = Laboratory.Application;
      LAt = Laboratory.Attachment;
      LAu = Laboratory.Authorization;
      LCl = Laboratory.Client;
      LEn = Laboratory.Enumeral;
      LFa = Laboratory.Failure;
      LPo = Laboratory.Post;
      LPr = Laboratory.Profile;
      LRe = Laboratory.Request;
      LRo = Laboratory.Rolodex;
      LTi = Laboratory.Timeline;
      if (config.accessToken) {
        (new LAu.Requested({
          accessToken: config.accessToken,
          origin: config.origin,
          scope: LAu.Scope.READWRITEFOLLOW
        })).start();
      } else {
        authorize();
      }
      callback = function() {
        go();
        return document.removeEventListener("LaboratoryAuthorizationReceived", callback);
      };
      return document.addEventListener("LaboratoryAuthorizationReceived", callback);
    };
    if (typeof Laboratory !== "undefined" && Laboratory !== null ? Laboratory.ready : void 0) {
      return run();
    } else {
      return document.addEventListener("LaboratoryInitializationReady", run);
    }
  };

  window.addEventListener("load", init);

  Σ = function() {
    var attribute, attributes, child, children, elt, j, len, name, value;
    name = arguments[0], attributes = arguments[1], children = 3 <= arguments.length ? slice.call(arguments, 2) : [];
    elt = document.createElement(String(name));
    if (attributes === Object(attributes)) {
      for (attribute in attributes) {
        value = attributes[attribute];
        if ((value != null) && value !== false) {
          elt.setAttribute(attribute, value === true ? "" : value);
        }
      }
    }
    for (j = 0, len = children.length; j < len; j++) {
      child = children[j];
      if (child != null) {
        elt.appendChild((child instanceof Node ? child : document.createTextNode(String(child))));
      }
    }
    return elt;
  };

  σ = function(name, attributes, innerHTML) {
    var attribute, elt, value;
    elt = document.createElement(String(name));
    if (attributes === Object(attributes)) {
      for (attribute in attributes) {
        value = attributes[attribute];
        if ((value != null) && value !== false) {
          elt.setAttribute(attribute, value === true ? "" : value);
        }
      }
    }
    elt.innerHTML = innerHTML;
    return elt;
  };

  Τ = function() {
    var element, j, len, node, nodes;
    element = arguments[0], nodes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (!(element instanceof Element)) {
      return;
    }
    element.textContent = "";
    for (j = 0, len = nodes.length; j < len; j++) {
      node = nodes[j];
      if (node != null) {
        element.appendChild((node instanceof Node ? node : document.createTextNode(String(node))));
      }
    }
    return element;
  };

  τ = function() {
    var element, j, len, node, nodes;
    element = arguments[0], nodes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (!(element instanceof Element)) {
      return;
    }
    for (j = 0, len = nodes.length; j < len; j++) {
      node = nodes[j];
      if (node != null) {
        element.insertBefore((node instanceof Node ? node : document.createTextNode(String(node))), this instanceof Node ? this : null);
      }
    }
    return element;
  };

  Ε = function(key, locale) {
    var result;
    key = String(key);
    if (locale == null) {
      locale = config.locale || "en";
    }
    locale = locale.toLowerCase();
    if (localized[locale] == null) {
      localized[locale] = {};
    }
    if (localized[locale][key] != null) {
      return localized[locale][key];
    }
    result = (function() {
      switch (false) {
        case !((Locales[locale] != null) && (Locales[locale][key] != null)):
          return Locales[locale][key];
        case locale !== "en":
          return key;
        default:
          return Ε(key, indexOf.call(locale, "-") >= 0 ? locale.substr(0, locale.indexOf("-")) : "en");
      }
    })();
    return localized[locale][key] = result;
  };

  authorize = function() {
    var button, handleEvent, input;
    handleEvent = function(event) {
      if ((event.type === "keypress" && event.target === input && (event.key === "Enter" || event.code === "Enter" || event.keyCode === 0x0D) || event.type === "click" && event.target === button) && input.value.length && input.validity.valid) {
        (new LAu.Request({
          name: config.title,
          origin: "https://" + input.value,
          redirect: config.basename,
          scope: LAu.Scope.READWRITEFOLLOW
        })).start(window.open("about:blank", "SnowOAuth"));
        return input.value = "";
      }
    };
    Τ(config.root, Σ("DIV", {
      id: "🌨🔓"
    }, Σ("H1", void 0, Ε("auth.query")), Σ("P", void 0, (Ε("auth.username")) + "@", input = Σ("INPUT", {
      pattern: "[0-9A-Za-z\\-\\.]+(\\:[0-9]{1,4})?",
      placeholder: Ε("auth.placeholder")
    }), button = Σ("BUTTON", void 0, "GO!"))));
    input.addEventListener("keypress", handleEvent);
    return button.addEventListener("click", handleEvent);
  };

  go = function() {
    Τ(config.root, Σ("A", {
      href: "#!/",
      target: "_self"
    }, Σ("HEADER", {
      id: "🌨▔"
    }, Σ("H1", void 0, config.title))), state.window = Σ("DIV", {
      id: "🌨🗔"
    }), state.composer = Σ("DIV", {
      id: "🌨📝"
    }));
    location.hash = "#!/";
    locate();
    return window.addEventListener("hashchange", locate);
  };

  locate = function() {
    var base, fn, hash, j, len, path;
    for (j = 0, len = cleanup.length; j < len; j++) {
      fn = cleanup[j];
      if (typeof fn === "function") {
        fn();
      }
    }
    cleanup = [];
    if (((hash = location.hash).substr(0, 3)) !== "#!/") {
      hash = "#!/";
    }
    path = (hash.substr(3)).split("/");
    base = path[0];
    state.location = (function() {
      switch (base) {
        case "":
        case void 0:
          return HOME;
        case Ε("location.global"):
          return GLOBAL;
        case Ε("location.local"):
          return LOCAL;
        case Ε("location.tag"):
          state.query = +path[1];
          return TAG;
        case Ε("location.user"):
          state.query = +path[1];
          switch (path[2]) {
            case Ε("location.media"):
              return USER | ONLY_MEDIA;
            case Ε("location.all"):
              return USER | WITH_MENTIONS;
            case "":
            case void 0:
              return USER;
            default:
              if (!isNaN(path[2])) {
                state.status = +path[2];
                return POST;
              } else {
                return NOTFOUND;
              }
          }
          break;
        default:
          return NOTFOUND;
      }
    })();
    if (state.location === NOTFOUND) {
      return notfound();
    } else {
      if (state.location & SHOW_USER) {
        user();
      } else {
        nobody();
      }
      if (state.location & SHOW_TIMELINE) {
        timeline();
      }
      if (state.location & SHOW_POST) {
        return post();
      }
    }
  };

  notfound = function() {
    state.timeline = null;
    return Τ(state.window, Σ("DIV", {
      id: "🌨🛇"
    }, Σ("H2", null, Ε("notfound.notfound")), Σ("P", null, Ε("notfound.message"))));
  };

  user = function() {
    var handleRequest, header, request;
    header = void 0;
    handleRequest = function(response) {
      if (!(response instanceof LPr)) {
        return;
      }
      return Τ(header, Σ("A", {
        href: response.header,
        target: "_blank"
      }, Σ("IMG", {
        alt: "Header image for " + (response.displayName || response.account),
        src: response.header
      })), Σ("A", {
        href: response.href,
        title: response.displayName,
        target: "_blank"
      }, Σ("IMG", {
        alt: (response.displayName || response.account) + "'s avatar",
        src: response.avatar
      }), Σ("H2", void 0, response.displayName), Σ("CODE", void 0, response.account)), σ("P", void 0, response.bio));
    };
    Τ(state.window, header = Σ("HEADER"), state.timeline = Σ("DIV", {
      id: "🌨📜"
    }));
    request = new LPr.Request({
      id: state.query
    });
    request.assign(handleRequest);
    request.start();
    return cleanup.push(request.stop);
  };

  nobody = function() {
    var AorB;
    AorB = function(useB, object, contents) {
      if (useB) {
        return Σ("B", void 0, contents);
      } else {
        return Σ("A", object, contents);
      }
    };
    return Τ(state.window, Σ("NAV", {
      id: "snow-navbar"
    }, AorB(state.location & SHOW_TIMELINE && !(state.location & FROM_PUBLIC), {
      href: "#!/",
      target: "_self"
    }, Ε("link.home")), AorB(state.location & SHOW_TIMELINE && state.location & ONLY_LOCAL, {
      href: "#!/" + Ε("location.local"),
      target: "_self"
    }, Ε("link.local")), AorB(state.location & SHOW_TIMELINE && state.location & FROM_PUBLIC && !(state.location & ONLY_LOCAL), {
      href: "#!/" + Ε("location.global"),
      target: "_self"
    }, Ε("link.global"))), state.timeline = Σ("DIV", {
      id: "🌨📜"
    }));
  };

  timeline = function() {
    var backRequest, handleBackRequest, handleRequest, renderStatus, request, timeout, tl, update;
    if (!((tl = state.timeline) instanceof Element)) {
      return;
    }
    timeout = null;
    update = function(req) {
      req.stop();
      req.remove(handleRequest);
      req = req.prev();
      req.assign(handleRequest);
      return req.start();
    };
    renderStatus = function(status) {
      var attachment, ref, scrollBottom;
      scrollBottom = tl.scrollHeight - tl.scrollTop;
      return Σ("ARTICLE", void 0, Σ("HEADER", void 0, Σ("A", {
        href: "#!/" + (Ε("location.user")) + "/" + status.author.id,
        target: "_self"
      }, Σ("IMG", {
        alt: (status.author.displayName || status.author.account) + "'s avatar",
        src: status.author.avatar
      })), Σ("A", {
        href: "#!/" + (Ε("location.user")) + "/" + status.author.id,
        target: "_self"
      }, Σ("B", void 0, status.author.displayName), Σ("CODE", void 0, status.author.localAccount))), Σ("DIV", {
        "class": "🌨📰",
        "data-snow-message": status.message ? status.message : void 0
      }, ((ref = status.mediaAttachments) != null ? ref.length : void 0) ? Σ("A", {
        href: "#!/" + [Ε("location.user"), status.author.id, status.id].join("/"),
        target: "_self"
      }, Σ.apply(null, ["FIGURE", {
        "data-snow-attachment-count": status.mediaAttachments.length,
        "data-snow-nsfw": !!status.isNSFW
      }].concat(slice.call((function() {
        var j, len, ref1, results;
        ref1 = status.mediaAttachments;
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          attachment = ref1[j];
          results.push((function() {
            var media;
            media = attachment.type & LAt.Type.VIDEO ? Σ("VIDEO", {
              controls: attachment.type !== LAt.Type.GIFV,
              loop: attachment.type === LAt.Type.GIFV,
              muted: attachment.type === LAt.Type.GIFV,
              poster: attachment.preview,
              src: attachment.href
            }) : Σ("IMG", {
              src: attachment.href
            });
            media.addEventListener("load", function() {
              return tl.scrollTop = tl.scrollHeight - scrollBottom;
            });
            if (attachment.type === LAt.Type.GIFV) {
              media.addEventListener("mouseover", media.play);
              media.addEventListener("mouseleave", media.pause);
            }
            return media;
          })());
        }
        return results;
      })())))) : void 0, σ("SECTION", void 0, status.content)), Σ.apply(null, ["FOOTER", void 0, Σ("A", {
        href: "#!/" + [Ε("location.user"), status.author.id, status.id].join("/"),
        target: "_self"
      }, status.datetime)].concat(slice.call((status.application ? [
        " • ", status.application.href ? Σ("A", {
          href: status.application.href,
          target: "_blank"
        }, status.application.name) : status.application.name
      ] : [])))));
    };
    handleRequest = function(response) {
      var doScroll, i;
      if (!(response instanceof LTi)) {
        return;
      }
      if (tl.scrollTop === tl.scrollHeight - tl.clientHeight) {
        doScroll = true;
      }
      if (response.length) {
        τ.apply(null, [tl].concat(slice.call((function() {
          var j, ref, results;
          results = [];
          for (i = j = ref = response.posts.length - 1; ref <= 0 ? j <= 0 : j >= 0; i = ref <= 0 ? ++j : --j) {
            results.push(renderStatus(response.posts[i]));
          }
          return results;
        })())));
        if (doScroll) {
          tl.scrollTop = tl.scrollHeight - tl.clientHeight;
        }
        return update(this);
      } else {
        return timeout = window.setTimeout(this.start, 3000);
      }
    };
    handleBackRequest = function(response) {
      var scrollBottom, status;
      if (!(response instanceof LTi)) {
        return;
      }
      scrollBottom = tl.scrollHeight - tl.scrollTop;
      if (response.length) {
        τ.call.apply(τ, [tl.firstElementChild, tl].concat(slice.call((function() {
          var j, len, ref, results;
          ref = response.posts;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            status = ref[j];
            results.push(renderStatus(status));
          }
          return results;
        })())));
      }
      return tl.scrollTop = tl.scrollHeight - scrollBottom;
    };
    request = new LTi.Request({
      type: (function() {
        switch (false) {
          case !(state.location & FROM_PUBLIC):
            return LTi.Type.PUBLIC;
          case !(state.location & FROM_TAG):
            return LTi.Type.HASHTAG;
          case !(state.location & FROM_USER):
            return LTi.Type.ACCOUNT;
          default:
            return LTi.Type.HOME;
        }
      })(),
      query: state.location & FROM_USER || state.location & FROM_TAG ? state.query : void 0,
      isLocal: state.location & ONLY_LOCAL
    });
    request.assign(handleRequest);
    request.start();
    backRequest = void 0;
    tl.addEventListener("scroll", function() {
      if (tl.scrollTop < 32 && request.response) {
        if (backRequest && !backRequest.response) {
          return;
        }
        if (backRequest) {
          backRequest.stop();
          backRequest.remove(handleBackRequest);
        }
        backRequest = (backRequest || request).next();
        backRequest.assign(handleBackRequest);
        return backRequest.start();
      }
    });
    return cleanup.push(function() {
      if (timeout != null) {
        window.clearTimeout(timeout);
      }
      request.stop();
      if (backRequest) {
        return backRequest.stop();
      }
    });
  };

  post = function() {};

}).call(this);
